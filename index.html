// --- VARIABLES GLOBALES DEL JUEGO ---
const REELS_DOM = [
    document.getElementById('reel-1'),
    document.getElementById('reel-2'),
    document.getElementById('reel-3')
];
const SALDO_DOM = document.getElementById('saldo-valor');
const SPIN_BUTTON = document.getElementById('spin-button');
const MESSAGE_DOM = document.getElementById('message');
const CLAIM_BUTTON = document.getElementById('claim-idle');
const IDLE_ACUMULADO_DOM = document.getElementById('idle-acumulado');

// SÃ­mbolos disponibles (usa emojis para simplicidad)
const SYMBOLS = ['ğŸ’', 'ğŸ‹', 'ğŸ””', 'â­', '7ï¸âƒ£']; 

// ConfiguraciÃ³n del Algoritmo (Paytable)
// RTP es la probabilidad de pago, crucial para la adicciÃ³n!
const PAYTABLE = {
    // 3 x SÃ­mbolo, Ganancia:
    '7ï¸âƒ£7ï¸âƒ£7ï¸âƒ£': 100,
    'â­â­â­': 50,
    'ğŸ””ğŸ””ğŸ””': 20,
    'ğŸ‹ğŸ‹ğŸ‹': 10,
    'ğŸ’ğŸ’ğŸ’': 5,
    // 2 x SÃ­mbolo, Ganancia (ej. 2 cerezas):
    'ğŸ’ğŸ’-': 2, 
    '-ğŸ’ğŸ’': 2,
    'ğŸ’-ğŸ’': 2 
    // MÃ¡s combinaciones pueden ser aÃ±adidas
};

// Variables de Estado del Jugador (Se usarÃ­a localStorage para persistir)
let gameState = {
    saldo: 50,
    costoSpin: 1,
    idleRate: 10, // Monedas por hora
    lastLogin: Date.now() 
};

// --- FUNCIONES DEL JUEGO ---

/**
 * 1. Algoritmo Pseudo-Aleatorio (PRNG)
 * Implementa la lÃ³gica de la tragamonedas.
 */
function spin() {
    if (gameState.saldo < gameState.costoSpin) {
        MESSAGE_DOM.textContent = 'Â¡Saldo insuficiente! Visita la tiendita o espera.';
        return;
    }

    // 1. Deducir costo y desactivar botÃ³n
    gameState.saldo -= gameState.costoSpin;
    updateUI();
    SPIN_BUTTON.disabled = true;
    MESSAGE_DOM.textContent = 'Â¡Girando...!';

    // 2. Generar resultados
    let results = [];
    const animationDuration = 1000; // Milisegundos
    let delay = 0;

    for (let i = 0; i < 3; i++) {
        // Genera un Ã­ndice aleatorio para cada rodillo
        const randomIndex = Math.floor(Math.random() * SYMBOLS.length);
        const resultSymbol = SYMBOLS[randomIndex];
        results.push(resultSymbol);
        
        // AnimaciÃ³n de los rodillos
        setTimeout(() => {
            REELS_DOM[i].textContent = resultSymbol;
        }, delay);
        delay += 300; // Un pequeÃ±o retraso para que parezcan parar en secuencia
    }

    // 3. Evaluar el resultado despuÃ©s de la animaciÃ³n
    setTimeout(() => {
        const winAmount = checkWin(results);
        handleWin(winAmount);
        SPIN_BUTTON.disabled = false;
        saveGameState();
    }, animationDuration + delay); 
}

/**
 * Verifica si la combinaciÃ³n es ganadora.
 */
function checkWin(results) {
    const r1 = results[0];
    const r2 = results[1];
    const r3 = results[2];
    let win = 0;

    // Verificar triple combinaciÃ³n
    if (r1 === r2 && r2 === r3) {
        win = PAYTABLE[r1 + r2 + r3] || 0;
    } 
    // Verificar dobles especÃ­ficos (ej. 2 cerezas)
    else if (r1 === 'ğŸ’' && r2 === 'ğŸ’') { win = PAYTABLE['ğŸ’ğŸ’-']; }
    else if (r2 === 'ğŸ’' && r3 === 'ğŸ’') { win = PAYTABLE['-ğŸ’ğŸ’']; }
    else if (r1 === 'ğŸ’' && r3 === 'ğŸ’') { win = PAYTABLE['ğŸ’-ğŸ’']; }

    return win;
}

/**
 * Maneja el pago de las ganancias.
 */
function handleWin(amount) {
    if (amount > 0) {
        gameState.saldo += amount;
        MESSAGE_DOM.textContent = `ğŸ‰ Â¡GANASTE ${amount} MONEDAS! ğŸ‰`;
    } else {
        MESSAGE_DOM.textContent = 'ğŸ˜” No tuviste suerte. Â¡Intenta de nuevo!';
    }
    updateUI();
}

/**
 * 2. MecÃ¡nica Idle Money (Dinero Pasivo)
 * Calcula y recoge el dinero acumulado desde la Ãºltima visita.
 */
function calculateIdleMoney() {
    const now = Date.now();
    const timeElapsedMs = now - gameState.lastLogin;
    const timeElapsedHours = timeElapsedMs / (1000 * 60 * 60); // Convertir a horas

    // Calcular el dinero ganado (Tasa * Horas Transcurridas)
    const totalIdle = Math.floor(timeElapsedHours * gameState.idleRate);

    // Opcional: Establecer un lÃ­mite mÃ¡ximo
    const maxIdle = 500; // Ejemplo de lÃ­mite
    const claimable = Math.min(totalIdle, maxIdle);

    IDLE_ACUMULADO_DOM.textContent = claimable;
    return claimable;
}

function claimIdleMoney() {
    const claimed = calculateIdleMoney();
    if (claimed > 0) {
        gameState.saldo += claimed;
        // Reiniciar el contador al momento actual
        gameState.lastLogin = Date.now(); 
        IDLE_ACUMULADO_DOM.textContent = 0;
        MESSAGE_DOM.textContent = `ğŸ¤‘ Recogiste ${claimed} monedas de la tiendita.`;
    } else {
        MESSAGE_DOM.textContent = 'AÃºn no hay monedas para recoger.';
    }
    updateUI();
    saveGameState();
}


// --- GESTIÃ“N DE LA UI Y PERSISTENCIA ---

/**
 * Actualiza el saldo en la interfaz.
 */
function updateUI() {
    SALDO_DOM.textContent = gameState.saldo;
    // Esto se podrÃ­a expandir para actualizar los precios de la tienda, etc.
}

/**
 * Guarda el estado del juego en el navegador.
 */
function saveGameState() {
    localStorage.setItem('maquinitaGameState', JSON.stringify(gameState));
}

/**
 * Carga el estado del juego.
 */
function loadGameState() {
    const savedState = localStorage.getItem('maquinitaGameState');
    if (savedState) {
        gameState = JSON.parse(savedState);
        // Asegurarse de que el saldo estÃ© en nÃºmero
        gameState.saldo = Number(gameState.saldo); 
    }
}


// --- INICIALIZACIÃ“N DEL JUEGO ---

document.addEventListener('DOMContentLoaded', () => {
    loadGameState(); // Cargar datos guardados
    updateUI();      // Actualizar la interfaz
    calculateIdleMoney(); // Calcular lo ganado mientras estuvo ausente

    // Asignar Eventos
    SPIN_BUTTON.addEventListener('click', spin);
    CLAIM_BUTTON.addEventListener('click', claimIdleMoney);

    // ActualizaciÃ³n de dinero Idle cada 10 segundos (para la sensaciÃ³n de progreso)
    setInterval(calculateIdleMoney, 10000); 
});

// Â¡Falta la lÃ³gica para comprar en la Tiendita! Eso serÃ­a el siguiente paso.
